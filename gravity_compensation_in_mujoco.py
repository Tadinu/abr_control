# -*- coding: utf-8 -*-
"""Gravity Compensation in MuJoCo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zlsplgSyk59hxnw3kOJMIxAXuwxXqOHD

## Installation and helper functions
"""

!pip install -q mujoco robot_descriptions mink
!command -v ffmpeg >/dev/null || (apt update && apt install -y ffmpeg)
!pip install -q mediapy

# Set up GPU rendering.
from google.colab import files
import distutils.util
import os
import subprocess
if subprocess.run('nvidia-smi').returncode:
  raise RuntimeError(
      'Cannot communicate with GPU. '
      'Make sure you are using a GPU Colab runtime. '
      'Go to the Runtime menu and select Choose runtime type.')

# Add an ICD config so that glvnd can pick up the Nvidia EGL driver.
# This is usually installed as part of an Nvidia driver package, but the Colab
# kernel doesn't install its driver via APT, and as a result the ICD is missing.
# (https://github.com/NVIDIA/libglvnd/blob/master/src/EGL/icd_enumeration.md)
NVIDIA_ICD_CONFIG_PATH = '/usr/share/glvnd/egl_vendor.d/10_nvidia.json'
if not os.path.exists(NVIDIA_ICD_CONFIG_PATH):
  with open(NVIDIA_ICD_CONFIG_PATH, 'w') as f:
    f.write("""{
    "file_format_version" : "1.0.0",
    "ICD" : {
        "library_path" : "libEGL_nvidia.so.0"
    }
}
""")

# Commented out IPython magic to ensure Python compatibility.
# %env MUJOCO_GL=egl
from pathlib import Path
import mujoco
import numpy as np
from robot_descriptions.loaders.mujoco import load_robot_description
from typing import Sequence
import mediapy as media

def get_body_body_ids(model: mujoco.MjModel, body_id: int) -> list[int]:
    """Get immediate children bodies belonging to a given body.

    Args:
        model: Mujoco model.
        body_id: ID of body.

    Returns:
        A list containing all child body ids.
    """
    return [
        i
        for i in range(model.nbody)
        if model.body_parentid[i] == body_id
        and body_id != i  # Exclude the body itself.
    ]


def get_subtree_body_ids(model: mujoco.MjModel, body_id: int) -> list[int]:
    """Get all bodies belonging to subtree starting at a given body.

    Args:
        model: Mujoco model.
        body_id: ID of body where subtree starts.

    Returns:
        A list containing all subtree body ids.
    """
    body_ids: list[int] = []
    stack = [body_id]
    while stack:
        body_id = stack.pop()
        body_ids.append(body_id)
        stack += get_body_body_ids(model, body_id)
    return body_ids

"""## Gravity compensation on ALOHA model

Let's compare 3 different gravity compensation implementations on the bimanual ALOHA platform.
"""

model = load_robot_description("aloha_mj_description")
data = mujoco.MjData(model)

model.stat.meansize = .5
model.vis.scale.forcewidth = .01

# Disable actuators.
model.opt.disableactuator = 1

# Get left and right arm bodies.
left_subtree_id = model.body("left/base_link").id
right_subtree_id = model.body("right/base_link").id
left_bodies = get_subtree_body_ids(model, left_subtree_id)
right_bodies = get_subtree_body_ids(model, right_subtree_id)
gravcomp_bodies = np.concatenate([left_bodies, right_bodies])

# Rendering options.
scene_option = mujoco.MjvOption()
scene_option.flags[mujoco.mjtVisFlag.mjVIS_PERTFORCE] = True
scene_option.flags[mujoco.mjtVisFlag.mjVIS_PERTOBJ] = True
fps = 30

#@title Without Gravity Compensation
mujoco.mj_resetDataKeyframe(model, data, 0)
frames = []
with mujoco.Renderer(model, height=480, width=640) as renderer:
    while data.time < 5.0:
        mujoco.mj_step(model, data)
        if len(frames) < data.time * fps:
            renderer.update_scene(
                data,
                camera="collaborator_pov",
                scene_option=scene_option
            )
            frames.append(renderer.render())
media.show_video(frames, fps=fps)

def gravcomp1(
    model: mujoco.MjModel,
    data: mujoco.MjData,
    body_ids: np.ndarray,
) -> None:
    # Make sure the applied forces are zeroed out before computing to avoid
    # accumulating forces from previous iterations.
    data.qfrc_applied[:] = 0.0
    jac = np.empty((3, model.nv))
    for i in body_ids:
        body_weight = model.opt.gravity * model.body(i).mass
        mujoco.mj_jac(model, data, jac, None, data.body(i).xipos, i)
        q_weight = jac.T @ body_weight
        data.qfrc_applied[:] -= q_weight


def gravcomp2(
    model: mujoco.MjModel,
    data: mujoco.MjData,
    body_ids: np.ndarray,
) -> None:
    # Make sure the applied forces are zeroed out before computing to avoid
    # accumulating forces from previous iterations.
    data.qfrc_applied[:] = 0.0
    for i in body_ids:
        body_weight = model.opt.gravity * model.body(i).mass
        mujoco.mj_applyFT(
            m=model,
            d=data,
            force=-body_weight,
            torque=np.zeros(3),
            point=data.body(i).xipos,
            body=i,
            qfrc_target=data.qfrc_applied,
        )

def gravcomp3(
    model: mujoco.MjModel,
    data: mujoco.MjData,
    subtree_ids: Sequence[int],
) -> None:
    # Make sure the applied forces are zeroed out before computing to avoid
    # accumulating forces from previous iterations.
    data.qfrc_applied[:] = 0.0
    jac = np.empty((3, model.nv))
    for subtree_id in subtree_ids:
        total_mass = model.body_subtreemass[subtree_id]
        mujoco.mj_jacSubtreeCom(model, data, jac, subtree_id)
        data.qfrc_applied[:] -= model.opt.gravity * total_mass @ jac

# Sanity check implementation.
gravcomp1(model, data, gravcomp_bodies)
qfrc1 = data.qfrc_applied.copy()

gravcomp2(model, data, gravcomp_bodies)
qfrc2 = data.qfrc_applied.copy()

gravcomp3(model, data, [left_subtree_id, right_subtree_id])
qfrc3 = data.qfrc_applied.copy()

np.testing.assert_allclose(qfrc1, qfrc2)
np.testing.assert_allclose(qfrc2, qfrc3)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# 
# gravcomp1(model, data, gravcomp_bodies)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# 
# gravcomp2(model, data, gravcomp_bodies)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# 
# gravcomp3(model, data, [left_subtree_id, right_subtree_id])

#@title With Gravity Compensation
mujoco.mj_resetDataKeyframe(model, data, 0)
mujoco.mj_forward(model, data)

scene_option = mujoco.MjvOption()
scene_option.flags[mujoco.mjtVisFlag.mjVIS_PERTFORCE] = True
scene_option.flags[mujoco.mjtVisFlag.mjVIS_PERTOBJ] = True

fps = 30
frames = []
with mujoco.Renderer(model, height=480, width=640) as renderer:
    while data.time < 15.0:
        # Perturb left arm.
        d = np.asarray([0, 1, 0, 0, 0, 0])
        f = 50 * np.sin(2 * np.pi * 0.1 * data.time)
        data.xfrc_applied[model.body("left/lower_forearm_link").id] = f * d
        # Perturb right arm.
        d = np.asarray([0, 1, 0, 0, 0, 0])
        f = 50 * np.sin(2 * np.pi * 0.1 * data.time + np.pi)
        data.xfrc_applied[model.body("right/lower_forearm_link").id] = f * d
        gravcomp3(model, data, [left_subtree_id, right_subtree_id])
        mujoco.mj_step(model, data)
        if len(frames) < data.time * fps:
            renderer.update_scene(
                data,
                camera="collaborator_pov",
                scene_option=scene_option
            )
            frames.append(renderer.render())
media.show_video(frames, fps=fps)

